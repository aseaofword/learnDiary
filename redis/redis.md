# redis面试总结

## 一、怎么用redis做延时队列

Redisson 内置的延时队列或者使用订阅发布功能的过期的channel，不过第二种方案有一些缺点，进入这个channel是在key被删除的时候，redis删除key有两种方案一种是惰性删除，一种是定期删除，惰性删除，只有在key被查询的时候才会对key对过期检查。如果是惰性删除策略的话，时间到期的时候也不会被放入channel，还有就是会丢消息，redis的发布订阅模式是不支持持久化的。

Redisson 是一个开源的 Java 语言 Redis 客户端，提供了很多开箱即用的功能，比如多种分布式锁的实现、延时队列。

我们可以借助 Redisson 内置的延时队列 RDelayedQueue 来实现延时任务功能。

Redisson 的延迟队列 RDelayedQueue 是基于 Redis 的 SortedSet 来实现的。SortedSet 是一个有序集合，其中的每个元素都可以设置一个分数，代表该元素的权重。Redisson 利用这一特性，将需要延迟执行的任务插入到 SortedSet 中，并给它们设置相应的过期时间作为分数。

Redisson 定期使用 `zrangebyscore` 命令扫描 SortedSet 中过期的元素，然后将这些过期元素从 SortedSet 中移除，并将它们加入到就绪消息列表中。就绪消息列表是一个阻塞队列，有消息进入就会被消费者监听到。这样做可以避免消费者对整个 SortedSet 进行轮询，提高了执行效率

相比于 Redis 过期事件监听实现延时任务功能，这种方式具备下面这些优势：

1. **减少了丢消息的可能**：DelayedQueue 中的消息会被持久化，即使 Redis 宕机了，根据持久化机制，也只可能丢失一点消息，影响不大。当然了，你也可以使用扫描数据库的方法作为补偿机制。
2. **消息不存在重复消费问题**：每个客户端都是从同一个目标队列中获取任务的，不存在重复消费的问题。

跟 Redisson 内置的延时队列相比，消息队列可以通过保障消息消费的可靠性、控制消息生产者和消费者的数量等手段来实现更高的吞吐量和更强的可靠性，实际项目中首选使用消息队列的延时消息这种方案。

## 二、缓存的读写策略有哪些？

### 旁路缓存模式

**写**：

- 先更新 db
- 然后直接删除 cache 。

**读** :

- 从 cache 中读取数据，读取到就直接返回
- cache 中读取不到的话，就从 db 中读取数据返回
- 再把数据放到 cache 中。

“**在写数据的过程中，可以先删除 cache ，后更新 db 么？**

那肯定是不行的！因为这样可能会造成 **数据库（db）和缓存（Cache）数据不一致**的问题。

### 读写穿透模式

**写（Write Through）：**

- 先查 cache，cache 中不存在，直接更新 db。
- cache 中存在，则先更新 cache，然后 cache 服务自己更新 db（**同步更新 cache 和 db**）。

**读(Read Through)：**

- 从 cache 中读取数据，读取到就直接返回 。
- 读取不到的话，先从 db 加载，写入到 cache 后返回响应。

### 异步缓存写入

但是，两个又有很大的不同：**Read/Write Through 是同步更新 cache 和 db，而 Write Behind 则是只更新缓存，不直接更新 db，而是改为异步批量的方式来更新 db。**

很明显，这种方式对数据一致性带来了更大的挑战，比如 cache 数据可能还没异步更新 db 的话，cache 服务可能就就挂掉了。

这种策略在我们平时开发过程中也非常非常少见，但是不代表它的应用场景少，比如消息队列中消息的异步写入磁盘、MySQL 的 Innodb Buffer Pool 机制都用到了这种策略。

Write Behind Pattern 下 db 的写性能非常高，非常适合一些数据经常变化又对数据一致性要求没那么高的场景，比如浏览量、点赞量。

## 三、redis的bitmap在生产环境中主要有哪些用途？

### 1.用户行为跟踪与活跃度统计

- **场景**：比如像签到、点击等事件
- **实现**：用户的id做key，日期（一年当中的第几天）做偏移量，可以统计日期当天是否签到，一个用户只需要365位，也就是46个字节。

### 2.实时在线用户统计

- **场景**：统计网站的在线用户人数
- **实现**：用户id作为偏移量，用户在线时设置为1，不在线时设置为0
- **优势**：可以用bitcount统计在线用户的数量
- **注意点**：用户id需要是连续的数值或者要做一层映射，如果是稀疏图的话会造成内存的浪费。

### **3. 权限管理与访问控制**

- **场景**：管理简单权限模型（如功能开关、角色权限）。
- **实现**：每个权限对应一个位（如位0=查看权限，位1=编辑权限），通过`GETBIT`检查权限。
- **示例**：`SETBIT permissions:user456 2 1`赋予用户编辑权限。

### **4. 限流与操作频率控制**

- **场景**：限制用户操作频率（如每秒1次API调用）。
- **实现**：按时间窗口划分位（如每分钟一个位），用户触发操作时设置对应位，通过检查位值判断是否允许操作。
- **示例**：`SETBIT rate_limit:user789 1623456780 1`记录用户在时间窗口内的操作。

### 5.布隆过滤器

- **场景**：高效判断元素是否存在（如缓存穿透保护）。
- **实现**：多个哈希函数将元素映射到位图中的多个位，检查所有位是否为`1`。存在误判但内存占用极低。
- **注意**：原生Redis 4.0后支持模块化布隆过滤器，性能更优。

## 四、redis的数据结构

### 1.SDS动态字符串

#### 	1.1空间预分配

​	当字符串大小小于1MB时，free=len，即分配和字符串长度相同的额外空间

​	当字符串大小大于1MB时，就只会分配1MB的free空间

#### 	1.2惰性回收

​	字符串缩短时不会立刻回收空间，为后续字符串增长时不用分配空间

### 2.链表

​	双向链表

### 3.字典

​	记录了两个map ht[0],ht[1]，日常的使用为ht[0]， ht[1]用来做rehash处理，还有一个rehashidx用来记录rehash的进度。

rehash的过程中如果是查询操作先查旧表再查新表，插入直接插入到新表

### 4.整数集合

​	只保存整数的集合，整数的大小由encoding来决定，有16位，32位，64位的单位，当一个大整数加入集合时会升级数组的其他元素然后放入末尾。

### 5.压缩列表

每个节点可以存储一个整数或者是字节数组。

previous_entry_length每个节点会记录上一个节点的大小，当前一个节点大小小于254字节时，用一个字节来记录大小，当前一个节点大小大于254字节时会用5个字节来记录大小，其中第一个字节为254即全1相当于一个标识了。主要是用来做从后往前遍历的。

连锁更新，如果一个entry的大小改变了，比如超过254了，下一个节点的previous_entry_length就要更新为5个字节即改变了自身的大小，那后续节点也需要更新。最坏情况为O(n)。

encoding字段，前两位来区分content的类型，后续存放content的长度，可能有一字节、两字节、五字节的形式。

00、01、10：字节数组

11：整数

## 五、数据库

### 1.数据库数量

由服务器的database配置来决定，默认是16，切换数据库select [数据库编号]。

### 2.过期键删除策略

#### 2.1定时器删除

给键设置一个过期时间的定时器，到时间了就主动删除。浪费cpu。

#### 2.2惰性删除

过期了也不删除，等到下次取的时候，这时候再判断是否过期，过期再删除。浪费内存

#### 2.3定期删除

每隔一段时间统一删除。折中，不过删除的执行时间和频率不好确定。

redis使用惰性删除和定期删除。

### 3.AOF、RDB和复制功能对过期键的处理

#### 3.1 RDB

**生成：**在执行SAVE或者BGSVAE命令时过期的键会被忽略。

**载入：**主数据库不会载入过期键，从数据库会，但是会在后续的同步中删除。

#### 3.2 AOF

**写入：**追加一条del命令

**重写：**忽略

### 4.复制时对过期键的处理

#### 4.1 主数据库

删除过期键然后向客户端返回null，再向从数据库发一条del命令

#### 4.2 从数据库

不做任何处理，如果客户端向从数据库发一条get命令，即使是过期也会照常返回。

## 六、主从数据库之间的复制

### 1.集群配置

从数据库 slaveof ip:port

### 2.原理

主数据库会维护一个近来的写命令缓冲区，主从数据库之间会维护一个offset，当从数据库掉线重连后主数据库会用offset在缓存区找offset即以后的字节，如果找到就做增量复制，如果没找到就做全量复制。全量复制是生成一份RDB传给了从数据库，很慢。所以要尽量避免全量复制，可以将缓冲区调大一点。公式：second*write_size_per_second，second为重连时间，write_size_per_second为每秒写指令数量。安全起见可以设为second*write_size_per_second*2。

